on:
  issues: 
    types: [labeled, unlabeled]
  workflow_dispatch:
    inputs:
      issue:
        description: 'Issue number to work with'
        required: true
        default: '11'
    
jobs:
  find-action-name:
    runs-on: ubuntu-latest
    #if: github.event.label.name == 'security-check'

    env:
      body: ${{ github.event.issue.body }}

    outputs:
      action: ${{ steps.get-action.outputs.action }}
      owner: ${{ steps.get-action.outputs.owner }}
      name: ${{ steps.get-action.outputs.name }}
      request_owner: ${{ steps.get-action.outputs.request_owner }}
      request_repo: ${{ steps.get-action.outputs.request_repo }}
      request_issue: ${{ steps.get-action.outputs.request_issue }}

    steps:
    - id: dispatch_issue_find
      run: |
         echo "Testing for dispatch event with issue number: ${{ github.event.inputs.issue }}"
         issue_number=${{ github.event.inputs.issue }}
         if [ "${{ github.event.inputs.issue }}" == "" ]; then
           echo "issue number not found in workflow dispatch event"
           echo 'Found the issue that triggered this event with number [${{ github.event.issue.number }}]'
           echo 'Found the issue title [${{ github.event.issue.title }}]'
         else
           echo "issue number found: [$issue_number]"
           # output a fixed variable
           echo "::set-output name=issue_number::${issue_number}"
         fi
         
         echo -e $body

    - uses: actions/github-script@v5
      name: Find action from comment
      id: get-action
      with:
        result-encoding: string
        script: |
            // todo, figure out pagination:

            const owner = context.repo.owner
            const repo = context.repo.repo
            let issue_number = context.issue.number

            if (issue_number == null) {
              // try to load issue number from other step:
              console.log(`issue number not found in context, searching for it in workflow dispatch step`)
              console.log(`issue number: [${{ steps.dispatch_issue_find.outputs.issue_number }}]`)
              issue_number = `${{ steps.dispatch_issue_find.outputs.issue_number }}`
            }

            console.log(`running with issue number [${issue_number}]`)

            if (issue_number == null) {
              core.setFailed('issue_number not found')
              return
            }

            // load all comments for this issue           
            const comments = await github.rest.issues.listComments({
              owner: owner,
              repo: repo,
              issue_number: issue_number,
            })

            // find the last comment
            let lastItem            
            if (comments.data.length > 0) {
              // find latest
              console.log(`using last comment's data`)
              lastItem = comments.data[comments.data.length-1]
            } else {
              // use issue body
              // todo
              console.log(`Can't find issue comment, we should use issue body. This is not supported yet.`)
            }

            const body = lastItem.body
            if (!body) {
              console.log(`can't load issue body`)

              let body = [
                "Couldn't find the action uses statement in the last comment.",
                "Please create a comment that only has `uses: owner/action-name` in it.",
                "",
                ":robot:"
              ]
              
              // create comment letting the user now what to do
              github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: body.join('\n')
              });

              core.setFailed(`Can't find action text in the last comment`)
              return
            }

            let action
            if (!body.startsWith('uses: ')) {              
              console.log('no action found')

              let body = [
                "Couldn't find the action uses statement in the last comment.",
                "Please create a comment that only has `uses: owner/action-name` in it.",
                "",
                ":robot:"
              ]
              
              // create comment letting the user now what to do
              github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: body.join('\n')
              });

              core.setFailed(`Can't find action text in the last comment`)
              return
            } 

            action = body.substring(6)
            let spaceIndex = action.indexOf(' ')
            if (spaceIndex > 0) {
              console.log(`found space at char [${spaceIndex}], cutting of the action text before it`)
              action = action.substring(0, spaceIndex)
            }
            console.log(`Found action with name [${action}]`)
            console.log(action)

            // return action
            let index = action.indexOf('/')
            let actionOwner = action.substring(0, index)
            let actionName = action.substring(index+1)

            console.log(`Found owner:${actionOwner}`)
            console.log(`Found action:${actionName}`)

            console.log(`::set-output name=action::${action}`)
            console.log(`::set-output name=owner::${actionOwner}`)
            console.log(`::set-output name=name::${actionName}`)
      
            console.log(`::set-output name=request_owner::${owner}`)            
            console.log(`::set-output name=request_repo::${repo}`)
            console.log(`::set-output name=request_issue::${issue_number}`)
    
  check-action-security-setup:
    runs-on: ubuntu-latest
    needs: find-action-name
    steps:
    - name: Check-out actions-request repo
      uses: actions/checkout@v2

    - name: Check-out referenced Action
      run: |
        git clone https://github.com/${{ needs.find-action-name.outputs.action }} action

    - name: Check for .github and workflows folder
      id: scan
      run: .github/security-scan.sh
      env:
        ACTION: ${{ needs.find-action-name.outputs.action }}
        
    - name: Update comment with results
      run: .github/update-issue-comment.sh
      env:
        HAS_GITHUB_FOLDER: ${{ steps.scan.outputs.has_github_folder }}
        HAS_WORKFLOWS_FOLDER: ${{ steps.scan.outputs.has_workflows_folder }}
        HAS_DEPENDABOT_CONFIGURATION: ${{ steps.scan.outputs.has_dependabot_configuration }}
        HAS_CODEQL_INIT: ${{ steps.scan.outputs.has_codeql_init }}
        WORKFLOW_WITH_CODEQL_INIT: ${{ steps.scan.outputs.workflow_with_codeql_init }}
        HAS_CODEQL_ANALYZE: ${{ steps.scan.outputs.has_codeql_analyze }}
        WORKFLOW_WITH_CODEQL_ANALYZE: ${{ steps.scan.outputs.workflow_with_codeql_analyze }}
        ACTION_USES_DOCKER: ${{ steps.scan.outputs.action_uses_docker }}
        HAS_LOW_MEDIUM_ISSUES: ${{ steps.scan.outputs.has_low_medium_issues }}
        LOW_MEDIUM_ISSUES: ${{ steps.scan.outputs.low_medium_issues }}
        HAS_HIGH_CRITICAL_ISSUES: ${{ steps.scan.outputs.has_high_critical_issues }}
        HIGH_CRITICAL_ISSUES: ${{ steps.scan.outputs.high_critical_issues }}

    - name: Get result for verification
      run: |
        echo "Owner: ${{needs.find-action-name.outputs.owner}}"
        echo "Name: ${{needs.find-action-name.outputs.name}}"

    # todo: add a new comment to the issue indication the action of forking the repo over to the other org?

  fork-action-test:
    runs-on: ubuntu-latest
    needs: find-action-name
    steps:
    - uses: actions/checkout@v2

    - name: Fork the action repository to rajbos-actions-test
      uses: rajbos-actions/forker@v0.0.1
      with:
        token: ${{ secrets.GH_TOKEN }}
        repo: ${{needs.find-action-name.outputs.name}}
        owner: ${{needs.find-action-name.outputs.owner}}
        org: rajbos-actions-test # todo: make central parameter

    # since dependabot alerts and dependency graph is enabled on the organization level, we only need to add a CodeQL setup
    # for it we need to inject the default CodeQL config into the forked action repository

    # todo: what if the action.yml indicates it runs in a docker image? Then we have not neccesarily a way to run CodeQL on actual CODE
    - uses: actions/github-script@v5
      name: Inject CodeQL workflow into new forked repository
      # todo: clear all other workflows first
      id: CodeQL
      env:
        repo: ${{needs.find-action-name.outputs.name}}
        org: rajbos-actions-test # todo: make central parameter
      with:      
        github-token: ${{ secrets.GH_TOKEN }}  
        script: |            
            const { repo, org } = process.env
            console.log(`Looking at this repository: [${org}/${repo}]`)

            const { readFileSync } = require('fs')
            const path = 'codeql-analysis.yml'
            const content = readFileSync(`${process.env.GITHUB_WORKSPACE}/${path}`)
            
            const targetPath = ".github/workflows/codeql-analysis.yml"
            console.log(`Checking to see if [${targetPath}] already exists in the forked repo`)
            
            // this call gives a 404, since the file does not exist, how to handle this?
            let data
            try {
               console.log(`before the call`)
               let { data } = await github.rest.repos.getContent({ 
                owner: org,
                repo,
                path: ".github/workflows/codeql-analysis.yml"  // todo: use variable here
              })
              console.log(`after the call`)

              console.log(`data:`)
              console.log(data)
              
              console.log(`data.content:`)
              console.log(data.content)
            }
            catch (e) {
              // strange: seems like we are not getting here at all :-(
              console.log(`in the catch with e:`)
              console.log(e)
            }
            console.log(`after the catch`)
            
            let content2
            if (data === undefined || data.content === undefined) {
              console.log('data is null, so workflow does not exist yet')
              content2 = content
            } else {
              console.log('data is not null, so does exist? We need to compare their hashes to see if we need to overwrite')
              content2 = Buffer.from(data.content.toString('base64'), 'base64')
              if (Buffer.from(data.content, 'base64').compare(content2) === 0) {
                console.log('data in the codeql workflow file is the same. Halting execution')
                return
              }
            }
                        
            console.log(`Uploading the CodeQL workflow to the forked repository`)
            github.rest.repos.createOrUpdateFileContents({
              owner: org,
              repo,
              path: targetPath,
              message: "Adding CodeQL setup",
              content: content2.toString('base64'),
              sha: data === undefined ? undefined : data.sha
            })

            console.log('CodeQL workflow uploaded')

            // todo: find the CodeQL workflow execution and wait for it to complete
            // todo: handle the result of the workflow execution: what if all languages fail?
            // todo: read the results from the CodeQL workflow
            // todo: generate random cron schedule?
